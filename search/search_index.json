{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u0130\u00e7indekiler \u00b6 G\u00f6m\u00fcl\u00fc Tipler","title":"\u0130\u00e7indekiler"},{"location":"#icindekiler","text":"G\u00f6m\u00fcl\u00fc Tipler","title":"\u0130\u00e7indekiler"},{"location":"sections/01-gomulu-tipler/","text":"G\u00f6m\u00fcl\u00fc Tipler \u00b6 Zero Value\u2019ler Rune ile Byte","title":"\u0130ndeks"},{"location":"sections/01-gomulu-tipler/#gomulu-tipler","text":"Zero Value\u2019ler Rune ile Byte","title":"G\u00f6m\u00fcl\u00fc Tipler"},{"location":"sections/01-gomulu-tipler/rune-ile-byte/","text":"Rune ile Byte \u00b6 rune asl\u0131nda int32 \u2019nin takma ad\u0131 ( alias\u2019\u0131 ). byte asl\u0131nda uint8 \u2019in takma ad\u0131. Tip De\u011fer int32 -2147483648 ile 2147483647 aras\u0131nda de\u011fer ta\u015f\u0131r. uint8 0 ile 255 aras\u0131nda de\u011fer ta\u015f\u0131r. u\u011fur 4 harfli bir isim. \u011f ise asl\u0131nda 8 bit i\u00e7in 2 byte \u2019l\u0131k bir de\u011fer. Halbuki rune ile 32 bit \u2019lik de\u011fer ta\u015f\u0131yabildi\u011fimiz i\u00e7in yani i\u00e7inde 32 bit \u2019lik de\u011ferler tutan bir slice oldu\u011fu i\u00e7in, rune olarak 4 karakter olan isim, byte olarak 5 karakter olur :) package main import \"fmt\" func main () { s := \"u\u011fur\" // \u011f \u00f6nemli fmt . Printf ( \"%10T %[1]v\\n\" , s ) fmt . Printf ( \"%10T %[1]v\\n\" , [] rune ( s )) fmt . Printf ( \"%10T %[1]v\\n\" , [] byte ( s )) } // string u\u011fur // []int32 [117 287 117 114] // 4 karakter // []uint8 [117 196 159 117 114] // 5 karakter","title":"Rune ile Byte"},{"location":"sections/01-gomulu-tipler/rune-ile-byte/#rune-ile-byte","text":"rune asl\u0131nda int32 \u2019nin takma ad\u0131 ( alias\u2019\u0131 ). byte asl\u0131nda uint8 \u2019in takma ad\u0131. Tip De\u011fer int32 -2147483648 ile 2147483647 aras\u0131nda de\u011fer ta\u015f\u0131r. uint8 0 ile 255 aras\u0131nda de\u011fer ta\u015f\u0131r. u\u011fur 4 harfli bir isim. \u011f ise asl\u0131nda 8 bit i\u00e7in 2 byte \u2019l\u0131k bir de\u011fer. Halbuki rune ile 32 bit \u2019lik de\u011fer ta\u015f\u0131yabildi\u011fimiz i\u00e7in yani i\u00e7inde 32 bit \u2019lik de\u011ferler tutan bir slice oldu\u011fu i\u00e7in, rune olarak 4 karakter olan isim, byte olarak 5 karakter olur :) package main import \"fmt\" func main () { s := \"u\u011fur\" // \u011f \u00f6nemli fmt . Printf ( \"%10T %[1]v\\n\" , s ) fmt . Printf ( \"%10T %[1]v\\n\" , [] rune ( s )) fmt . Printf ( \"%10T %[1]v\\n\" , [] byte ( s )) } // string u\u011fur // []int32 [117 287 117 114] // 4 karakter // []uint8 [117 196 159 117 114] // 5 karakter","title":"Rune ile Byte"},{"location":"sections/01-gomulu-tipler/zero-valueler/","text":"Zero Value\u2019ler \u00b6 Tipler, otomatik olarak, kendi zero value\u2019leri ile initialize edilir. Yani; var s string dendi\u011fi zaman, s otomatik olarak string \u2019in zero value\u2019s\u00fc olan \"\" de\u011ferini al\u0131r ve art\u0131k s \u2019in de\u011feri bo\u015f string; \"\" olur. var anahtar kelimesini g\u00f6r\u00fcnce declare and initialize oluyor diye d\u00fc\u015f\u00fcnmeli. Tip Zero Value\u2019su string \"\" int 0 float64 0 rune 0 byte 0 struct{} {} []int [] map[string]struct{} map[] *int nil interface{} nil func() nil chan struct{} nil Byte cinsinden kaplad\u0131klar\u0131 haf\u0131za alanlar\u0131: package main import ( \"fmt\" \"os\" \"text/tabwriter\" \"unsafe\" ) var ( s string r rune b byte i int ii * int f float64 ff func () eif interface {} ss struct {} ch chan struct {} slc [] struct {} mp map [ string ] struct {} ) func main () { w := tabwriter . NewWriter ( os . Stdout , 0 , 0 , 0 , ' ' , tabwriter . AlignRight | tabwriter . Debug ) fmt . Fprintf ( w , \"string\\t%v\\tbytes\\n\" , unsafe . Sizeof ( s )) fmt . Fprintf ( w , \"rune\\t%v\\tbytes\\n\" , unsafe . Sizeof ( r )) fmt . Fprintf ( w , \"byte\\t%v\\tbytes\\n\" , unsafe . Sizeof ( b )) fmt . Fprintf ( w , \"int\\t%v\\tbytes\\n\" , unsafe . Sizeof ( i )) fmt . Fprintf ( w , \"*int\\t%v\\tbytes\\n\" , unsafe . Sizeof ( ii )) fmt . Fprintf ( w , \"float64\\t%v\\tbytes\\n\" , unsafe . Sizeof ( f )) fmt . Fprintf ( w , \"function\\t%v\\tbytes\\tnil?\\t%t\\n\" , unsafe . Sizeof ( ff ), ff == nil ) fmt . Fprintf ( w , \"interface{}\\t%v\\tbytes\\tnil?\\t%t\\n\" , unsafe . Sizeof ( eif ), eif == nil ) fmt . Fprintf ( w , \"struct{}\\t%v\\tbytes\\n\" , unsafe . Sizeof ( ss )) fmt . Fprintf ( w , \"chan struct{}\\t%v\\tbytes\\tnil?\\t%t\\n\" , unsafe . Sizeof ( ch ), ch == nil ) fmt . Fprintf ( w , \"[]struct{}\\t%v\\tbytes\\tnil?\\t%t\\n\" , unsafe . Sizeof ( slc ), slc == nil ) fmt . Fprintf ( w , \"map[string]struct{}\\t%v\\tbytes\\tnil?\\t%t\\n\" , unsafe . Sizeof ( mp ), mp == nil ) w . Flush () } // string|16|bytes // rune| 4|bytes // byte| 1|bytes // int| 8|bytes // *int| 8|bytes // float64| 8|bytes // function| 8|bytes|nil?|true // interface{}|16|bytes|nil?|true // struct{}| 0|bytes // chan struct{}| 8|bytes|nil?|true // []struct{}|24|bytes|nil?|true // map[string]struct{}| 8|bytes|nil?|true Word B\u00fcy\u00fckl\u00fc\u011f\u00fc ( size ) \u00b6 Integer ve Pointer \u2019lar\u0131 haf\u0131zaya yerle\u015ftirmek i\u00e7in ( memory allocation ) kullan\u0131lan \u00f6l\u00e7\u00fc word \u2019d\u00fcr. Ayn\u0131 Amiga 68000 assembly\u2019deki gibi; byte , word , long-word ... 32 bit i\u015flemci i\u00e7in 4 byte tahis edilir. 64 bit i\u015flemci i\u00e7in 8 byte tahis edilir.","title":"Zero Value\u2019ler"},{"location":"sections/01-gomulu-tipler/zero-valueler/#zero-valueler","text":"Tipler, otomatik olarak, kendi zero value\u2019leri ile initialize edilir. Yani; var s string dendi\u011fi zaman, s otomatik olarak string \u2019in zero value\u2019s\u00fc olan \"\" de\u011ferini al\u0131r ve art\u0131k s \u2019in de\u011feri bo\u015f string; \"\" olur. var anahtar kelimesini g\u00f6r\u00fcnce declare and initialize oluyor diye d\u00fc\u015f\u00fcnmeli. Tip Zero Value\u2019su string \"\" int 0 float64 0 rune 0 byte 0 struct{} {} []int [] map[string]struct{} map[] *int nil interface{} nil func() nil chan struct{} nil Byte cinsinden kaplad\u0131klar\u0131 haf\u0131za alanlar\u0131: package main import ( \"fmt\" \"os\" \"text/tabwriter\" \"unsafe\" ) var ( s string r rune b byte i int ii * int f float64 ff func () eif interface {} ss struct {} ch chan struct {} slc [] struct {} mp map [ string ] struct {} ) func main () { w := tabwriter . NewWriter ( os . Stdout , 0 , 0 , 0 , ' ' , tabwriter . AlignRight | tabwriter . Debug ) fmt . Fprintf ( w , \"string\\t%v\\tbytes\\n\" , unsafe . Sizeof ( s )) fmt . Fprintf ( w , \"rune\\t%v\\tbytes\\n\" , unsafe . Sizeof ( r )) fmt . Fprintf ( w , \"byte\\t%v\\tbytes\\n\" , unsafe . Sizeof ( b )) fmt . Fprintf ( w , \"int\\t%v\\tbytes\\n\" , unsafe . Sizeof ( i )) fmt . Fprintf ( w , \"*int\\t%v\\tbytes\\n\" , unsafe . Sizeof ( ii )) fmt . Fprintf ( w , \"float64\\t%v\\tbytes\\n\" , unsafe . Sizeof ( f )) fmt . Fprintf ( w , \"function\\t%v\\tbytes\\tnil?\\t%t\\n\" , unsafe . Sizeof ( ff ), ff == nil ) fmt . Fprintf ( w , \"interface{}\\t%v\\tbytes\\tnil?\\t%t\\n\" , unsafe . Sizeof ( eif ), eif == nil ) fmt . Fprintf ( w , \"struct{}\\t%v\\tbytes\\n\" , unsafe . Sizeof ( ss )) fmt . Fprintf ( w , \"chan struct{}\\t%v\\tbytes\\tnil?\\t%t\\n\" , unsafe . Sizeof ( ch ), ch == nil ) fmt . Fprintf ( w , \"[]struct{}\\t%v\\tbytes\\tnil?\\t%t\\n\" , unsafe . Sizeof ( slc ), slc == nil ) fmt . Fprintf ( w , \"map[string]struct{}\\t%v\\tbytes\\tnil?\\t%t\\n\" , unsafe . Sizeof ( mp ), mp == nil ) w . Flush () } // string|16|bytes // rune| 4|bytes // byte| 1|bytes // int| 8|bytes // *int| 8|bytes // float64| 8|bytes // function| 8|bytes|nil?|true // interface{}|16|bytes|nil?|true // struct{}| 0|bytes // chan struct{}| 8|bytes|nil?|true // []struct{}|24|bytes|nil?|true // map[string]struct{}| 8|bytes|nil?|true","title":"Zero Value\u2019ler"},{"location":"sections/01-gomulu-tipler/zero-valueler/#word-buyuklugu-size","text":"Integer ve Pointer \u2019lar\u0131 haf\u0131zaya yerle\u015ftirmek i\u00e7in ( memory allocation ) kullan\u0131lan \u00f6l\u00e7\u00fc word \u2019d\u00fcr. Ayn\u0131 Amiga 68000 assembly\u2019deki gibi; byte , word , long-word ... 32 bit i\u015flemci i\u00e7in 4 byte tahis edilir. 64 bit i\u015flemci i\u00e7in 8 byte tahis edilir.","title":"Word B\u00fcy\u00fckl\u00fc\u011f\u00fc (size)"}]}