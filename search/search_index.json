{"config":{"lang":["tr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\u0130\u00e7indekiler","text":"<p>Bu notlar, <code>go1.19.6</code> versiyonu kullan\u0131larak haz\u0131rlanm\u0131\u015ft\u0131r.</p> <ul> <li>Dil Kurallar\u0131</li> <li>G\u00f6m\u00fcl\u00fc Tipler</li> </ul>"},{"location":"sections/00-kurallar/","title":"Dil Kurallar\u0131","text":""},{"location":"sections/00-kurallar/#unicode","title":"Unicode","text":"<p>Go, otomatik olarak <code>UTF-8</code> karakter d\u00f6n\u00fc\u015f\u00fcm format\u0131 kullan\u0131yor. Bu \u015fu anlama geliyor; kod i\u00e7inde T\u00fcrk\u00e7e de\u011fi\u015fken ad\u0131 (variable name/identifier) kullan\u0131labilir:</p> <pre><code>kullan\u0131c\u0131Ad\u0131 := \"u\u011fur\"\n</code></pre> <p>tamamen ge\u00e7erli (valid) bir ifade olmas\u0131na ra\u011fmen kullan\u0131lmasa iyi olur. Hangi t\u00fcr karakterler kullan\u0131labilir?</p> <ul> <li>Unicode kampsam\u0131ndaki t\u00fcm karakterler ve <code>_</code> karakteri</li> <li><code>0</code>\u2019dan <code>9</code>\u2019a kadar 10\u2019luk (decimal) say\u0131 sistemi i\u00e7in</li> <li><code>0</code>\u2019dan <code>7</code>\u2019ye kadar 8\u2019lik (octal) say\u0131 sistemi i\u00e7in</li> <li><code>0</code>\u2019dan <code>9</code>\u2019a ve <code>A</code>\u2019dan <code>F</code>\u2019e kadar 16\u2019l\u0131k (hexadecimal) say\u0131 sistemi i\u00e7in</li> </ul> <p>kullan\u0131labilir.</p> <p>Keza kaynak kod da <code>UTF-8</code> olarak kaydedilmelidir. Geli\u015ftirme yapt\u0131\u011f\u0131m\u0131z <code>main.go</code> dosyas\u0131n\u0131n da karakter tipi (encoding type) <code>UTF-8</code> olmal\u0131d\u0131r.</p>"},{"location":"sections/00-kurallar/#anahtar-kelimeler","title":"Anahtar Kelimeler","text":"<p>Toplam 25 tane anahtar kelimeden olu\u015fur.</p> <pre><code>break        default      func         interface    select\ncase         defer        go           map          struct\nchan         else         goto         package      switch\nconst        fallthrough  if           range        type\ncontinue     for          import       return       var\n</code></pre> <p>Bunlara ek olarak;</p> <ul> <li>Mant\u0131ksal sabitler (boolean constants) i\u00e7in; <code>true</code>, <code>false</code></li> <li>Say\u0131sal sabit (integer constants) i\u00e7in; <code>iota</code></li> <li>\u00d6n tan\u0131ml\u0131 i\u015faret\u00e7i olrak (predeclared identifier); <code>nil</code></li> </ul> <p>Tipler i\u00e7in;</p> <pre><code>int      int8     int16    int32      int64\nuint     uint8    uint16   uint32     uint64\nuintptr  float32  float64  complex64  complex128\nbool     byte     rune     string     error\n</code></pre> <p>Fonksiyonlar i\u00e7in;</p> <pre><code>make     len   new   append copy     close\ncomplex  real  imag  panic  recover  delete\n</code></pre> <p>gibi kelimeler de bulunur.</p>"},{"location":"sections/00-kurallar/#operatorler-ve-noktalama-isaretleri","title":"Operat\u00f6rler ve Noktalama \u0130\u015faretleri","text":"<p>Matematik i\u015flemleri, mant\u0131k i\u015flemleri, gruplama, bit i\u015flemleri ve benzeri operasyonlarda kullanabilece\u011fimiz operat\u00f6r karakterleri:</p> <pre><code>+    &amp;     +=    &amp;=     &amp;&amp;    ==    !=    (    )\n-    |     -=    |=     ||    &lt;     &lt;=    [    ]\n*    ^     *=    ^=     &lt;-    &gt;     &gt;=    {    }\n/    &lt;&lt;    /=    &lt;&lt;=    ++    =     :=    ,    ;\n%    &gt;&gt;    %=    &gt;&gt;=    --    !     ...   .    :\n&amp;^          &amp;^=          ~\n</code></pre>"},{"location":"sections/00-kurallar/#isaretciler-identifiers","title":"\u0130\u015faret\u00e7iler (Identifiers)","text":"<p>@wip</p>"},{"location":"sections/01-gomulu-tipler/","title":"G\u00f6m\u00fcl\u00fc Tipler","text":"<ul> <li>string\u2019ler</li> <li>bool\u2019lar</li> <li>N\u00fcmerikler</li> <li>Zero Value\u2019ler</li> <li>Rune ile Byte</li> </ul>"},{"location":"sections/01-gomulu-tipler/boollar/","title":"<code>bool</code>\u2019lar","text":"<p>@wip</p>"},{"location":"sections/01-gomulu-tipler/jenerikler/","title":"Jenerikler","text":"<p>@wip</p>"},{"location":"sections/01-gomulu-tipler/kompozit-tipler/","title":"Kompozit Tipler","text":"<p>@wip</p>"},{"location":"sections/01-gomulu-tipler/numerikler/","title":"N\u00fcmerikler","text":"<p>@wip</p>"},{"location":"sections/01-gomulu-tipler/rune-ile-byte/","title":"Rune ile Byte","text":"<ul> <li><code>rune</code> asl\u0131nda <code>int32</code>\u2019nin takma ad\u0131 (alias\u2019\u0131).</li> <li><code>byte</code> asl\u0131nda <code>uint8</code>\u2019in takma ad\u0131.</li> </ul> Tip De\u011fer <code>int32</code> <code>-2147483648</code> ile <code>2147483647</code> aras\u0131nda de\u011fer ta\u015f\u0131r. <code>uint8</code> <code>0</code> ile <code>255</code> aras\u0131nda de\u011fer ta\u015f\u0131r. <p><code>u\u011fur</code> 4 harfli bir isim. <code>\u011f</code> ise asl\u0131nda <code>8 bit</code> i\u00e7in <code>2 byte</code>\u2019l\u0131k bir de\u011fer. Halbuki <code>rune</code> ile <code>32 bit</code>\u2019lik de\u011fer ta\u015f\u0131yabildi\u011fimiz i\u00e7in yani i\u00e7inde <code>32 bit</code>\u2019lik de\u011ferler tutan bir slice oldu\u011fu i\u00e7in, <code>rune</code> olarak 4 karakter olan isim, <code>byte</code> olarak 5 karakter olur :)</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\ns := \"u\u011fur\" // \u011f \u00f6nemli\n\nfmt.Printf(\"%10T %[1]v\\n\", s)\nfmt.Printf(\"%10T %[1]v\\n\", []rune(s))\nfmt.Printf(\"%10T %[1]v\\n\", []byte(s))\n}\n\n//  string u\u011fur\n// []int32 [117 287 117 114]     // 4 karakter\n// []uint8 [117 196 159 117 114] // 5 karakter\n</code></pre>"},{"location":"sections/01-gomulu-tipler/stringler/","title":"<code>string</code>\u2019ler","text":"<p>@wip</p>"},{"location":"sections/01-gomulu-tipler/zero-valueler/","title":"Zero Value\u2019ler","text":"<p>Tipler, otomatik olarak, kendi zero value\u2019leri ile <code>initialize</code> edilir. Yani; <code>var s string</code> dendi\u011fi zaman, <code>s</code> otomatik olarak <code>string</code>\u2019in zero value\u2019s\u00fc olan <code>\"\"</code> de\u011ferini al\u0131r ve art\u0131k <code>s</code>\u2019in de\u011feri bo\u015f string; <code>\"\"</code> olur.</p> <p><code>var</code> anahtar kelimesini g\u00f6r\u00fcnce declare and initialize oluyor diye d\u00fc\u015f\u00fcnmeli.</p> Tip Zero Value\u2019su <code>string</code> <code>\"\"</code> <code>int</code> <code>0</code> <code>float64</code> <code>0</code> <code>rune</code> <code>0</code> <code>byte</code> <code>0</code> <code>struct{}</code> <code>{}</code> <code>[]int</code> <code>[]</code> <code>map[string]struct{}</code> <code>map[]</code> <code>*int</code> <code>nil</code> <code>interface{}</code> <code>nil</code> <code>func()</code> <code>nil</code> <code>chan struct{}</code> <code>nil</code> <p>Byte cinsinden kaplad\u0131klar\u0131 haf\u0131za alanlar\u0131:</p> <pre><code>package main\n\nimport (\n\"fmt\"\n\"os\"\n\"text/tabwriter\"\n\"unsafe\"\n)\n\nvar (\ns   string\nr   rune\nb   byte\ni   int\nii  *int\nf   float64\nff  func()\neif interface{}\nss  struct{}\nch  chan struct{}\nslc []struct{}\nmp  map[string]struct{}\n)\n\nfunc main() {\nw := tabwriter.NewWriter(os.Stdout, 0, 0, 0, ' ', tabwriter.AlignRight|tabwriter.Debug)\n\nfmt.Fprintf(w, \"string\\t%v\\tbytes\\n\", unsafe.Sizeof(s))\nfmt.Fprintf(w, \"rune\\t%v\\tbytes\\n\", unsafe.Sizeof(r))\nfmt.Fprintf(w, \"byte\\t%v\\tbytes\\n\", unsafe.Sizeof(b))\nfmt.Fprintf(w, \"int\\t%v\\tbytes\\n\", unsafe.Sizeof(i))\nfmt.Fprintf(w, \"*int\\t%v\\tbytes\\n\", unsafe.Sizeof(ii))\nfmt.Fprintf(w, \"float64\\t%v\\tbytes\\n\", unsafe.Sizeof(f))\nfmt.Fprintf(w, \"function\\t%v\\tbytes\\tnil?\\t%t\\n\", unsafe.Sizeof(ff), ff == nil)\nfmt.Fprintf(w, \"interface{}\\t%v\\tbytes\\tnil?\\t%t\\n\", unsafe.Sizeof(eif), eif == nil)\nfmt.Fprintf(w, \"struct{}\\t%v\\tbytes\\n\", unsafe.Sizeof(ss))\nfmt.Fprintf(w, \"chan struct{}\\t%v\\tbytes\\tnil?\\t%t\\n\", unsafe.Sizeof(ch), ch == nil)\nfmt.Fprintf(w, \"[]struct{}\\t%v\\tbytes\\tnil?\\t%t\\n\", unsafe.Sizeof(slc), slc == nil)\nfmt.Fprintf(w, \"map[string]struct{}\\t%v\\tbytes\\tnil?\\t%t\\n\", unsafe.Sizeof(mp), mp == nil)\n\nw.Flush()\n}\n\n//              string|16|bytes\n//                rune| 4|bytes\n//                byte| 1|bytes\n//                 int| 8|bytes\n//                *int| 8|bytes\n//             float64| 8|bytes\n//            function| 8|bytes|nil?|true\n//         interface{}|16|bytes|nil?|true\n//            struct{}| 0|bytes\n//       chan struct{}| 8|bytes|nil?|true\n//          []struct{}|24|bytes|nil?|true\n// map[string]struct{}| 8|bytes|nil?|true\n</code></pre>"},{"location":"sections/01-gomulu-tipler/zero-valueler/#word-buyuklugu-size","title":"Word B\u00fcy\u00fckl\u00fc\u011f\u00fc (size)","text":"<p>Integer ve Pointer\u2019lar\u0131 haf\u0131zaya yerle\u015ftirmek i\u00e7in (memory allocation) kullan\u0131lan \u00f6l\u00e7\u00fc word\u2019d\u00fcr. Ayn\u0131 Amiga 68000 assembly\u2019deki gibi; <code>byte</code>, <code>word</code>, <code>long-word</code> ...</p> <ul> <li>32 bit i\u015flemci i\u00e7in <code>4 byte</code> tahis edilir.</li> <li>64 bit i\u015flemci i\u00e7in <code>8 byte</code> tahis edilir.</li> </ul>"}]}